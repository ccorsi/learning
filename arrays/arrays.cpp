/**
 * @file arrays.cpp
 * @author Claudio Corsi (clcorsi@yahoo.com)
 * @brief This file contains different implementations of the array manipulation algorithms
 *  that where part of the list extracted from
 *  https://medium.com/techie-delight/500-data-structures-and-algorithms-practice-problems-35afe8a1e222
 *
 * @version 0.1
 * @date 2022-04-14
 *
 * @copyright Copyright (c) 2022 Claudio Corsi
 *
 * @license MIT License https://raw.githubusercontent.com/ccorsi/learning/main/LICENSE
 */

#include <iostream>
#include <set>
#include <unordered_set>
#include <unordered_map>

#include "arrays.h"

using namespace valhalla;

namespace valhalla {

    bool find_pair(std::vector<int>& values, int target, std::pair<int,int>& result) {
        std::unordered_set<int> entries;

        for(auto itr = values.begin() ; itr != values.end() ; itr++) {
            auto found = entries.find(target - *itr);
            if (found != entries.end()) {
                result.first = target - *itr;
                result.second = *itr;
                return true;
            } else {
                entries.insert(*itr);
            }
        }

        // not pair of entries were found that summed to the passed target value
        return false;

    }

    bool find_subarray_with_zero_sum(std::vector<int>& values) {
        // this will contain all of the current sums for all of the already processed values
        // the set is generated by iterating through the values and summing them together as
        // we iterate.  We then add each summation to this set.  While we do that we also
        // check if the summed value is already in the set.  If it is, then we know that the
        // first n entries will contain a subarray up to n entries that sum to zero.
        std::unordered_set<int> sums;
        int sum = 0;
        sums.insert(0);

        for(auto value = values.begin() ; value != values.end() ; value++ ) {
            sum += *value;

            // check if the sum is part of the summed entries
            if (sums.find(sum) != sums.end()) {
                // there is a subset of entries that sum to zero
                return true;
            }

            // store the current sum to be checked with the next set of values
            sums.insert(sum);
        }

        // no sum was found that sums to zero
        return false;
    }

    int print_all_subarrays_with_zero_sum(std::vector<int>& values, std::ostream& os) {
        // this map will store the ending index for all of the subarrays with the same sum
        std::unordered_multimap<int,int> indexes;

        // set the (0, -1) pair to handle the case that the zero sum starts at index 0
        indexes.insert(std::pair<int,int>(0,-1));

        int sum = 0;
        int idx = 0;
        int count = 0;

        for(auto value = values.begin() ; value != values.end() ; value++, idx++) {
            // sum the currently processed entries
            sum += *value;

            auto found = indexes.find(sum);
            if (found != indexes.end()) {
                // print all subarrays indexes associated to the current value
                for ( ; found != indexes.end() && found->first == sum ; found++ ) {
                    os << "Subarray [" << found->second + 1 << ".." << idx << "]" << std::endl;
                    count++;
                }
            }

            // insert current sum for the current value
            indexes.insert(std::pair<int,int>(sum, idx));
        }

        return count;
    }

}
