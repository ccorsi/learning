// standard libraries
#include <vector>

// google tests library
#include "gtest/gtest.h"

// generally defined search and helper libraries
#include "graph.h"
#include "ucs.h"
#include "city.h"
#include "utils.h"

using namespace std;

/**
 * @brief This is used to store the different city and distance information
 *      that will be used to generate the required data structures used by
 *      the tests.
 */
struct city_data {
    string from;
    string to;
    int distance;
};

typedef struct city_data city_data;

template<typename E, typename K>
struct data_key {
public:
    E from;
    E to;
    K distance;
};

/**
 * @brief This is used to create the necessary data structures that will be used by the
 *      tests.
 * 
 * @param data  This contains the city/distance information that will be used to populate the distances 
 * @param distances This will be populated with the information that was passed by the data
 * @param cities This will be populated with the information that was passed by the data
 */
void create_graph(vector<city_data>& data, map<string,map<string,int> >& distances, list<array<string,2> >& cities) {
    // populate the map so that we can use this information to determine the different distances between the two cities.
    for(auto itr = data.begin() ; itr != data.end() ; itr++) {
        auto data = *itr;
        // update the distances map
        map<string,int> source = distances[data.from];
        source[data.to] = data.distance;
        source = distances[data.to];
        source[data.from] = data.distance;
        // add to the cities list
        cities.push_back({ data.from, data.to });
    }    
}

node<city> create_city_node(string& name) {
    return node<city>(city(name));
}

class cmp {
private:
    map<string,map<string,int> >& m_distances;
public:
    cmp(map<string,map<string,int> >& distances) : m_distances(distances) {}
};

TEST(UniformCostSearchTestSuite, SimpleUniformCostSearchTest) {
    map<string,map<string,int> > distances;
    list<array<string,2> > cities;
    vector<city_data> data = {
        { "Duluth", "Sault Ste. Marie", 110 },
        { "Sault Ste. Marie", "Toronto", 90 },
        { "Toronto", "Pittsburgh", 80 },
        { "Duluth", "Chicago", 157 },
        { "Chicago", "Pittsburgh", 81 },
    };
    
    create_graph(data, distances, cities);

    node<city> root;
    list<city> path;
    map<string,node<city> > valueMap;

    create_graph_map(cities, valueMap, create_city_node);

    list<string> expected = { "a", "b", "e", "f" };

    string source = "Duluth";
    string destination = "Pittsburgh";

    // ASSERT_TRUE(ucs(valueMap[source], destination, path, cmp(distances)));

    // ASSERT_EQ(path, expected);

}

TEST(NodeTestSuite, NodeTest) {
    string data("Foo");
    
    node<string> n(data);

    string name = n();

    cout << "name: " << name << endl;
}

struct key_data {
    string name;
    int key;

    bool operator>(const key_data& other) const { return key > other.key; }
};

typedef struct key_data key_data;

TEST(PriorityQueueExtendedTestSuite, FirstTest) {
    vector<key_data> data = {
     { string("one"), 11 },
     { string("two"), 5 },
     { string("three"), 6},
     { string("four"), 99 },
    };

    priority_queue_ex<key_data> pq;

    for(auto itr = data.begin() ; itr != data.end() ; itr++) {
        pq.push(*itr);
    }

    cout << "Printing the priority queue entries in expected order" << endl;
    while ( ! pq.empty() ) {
        auto value = pq.top();
        pq.pop(); // remove the added entry.

        cout << "name: " << value.name << ", key: " << value.key << endl;
    }
}

/**
 * @brief This is a simple facade class that will be used to add entries to the priority queue sub-class
 *
 * @tparam E The type of elements that this facade will wrap
 * @tparam K The type of the key that will be used to order the entries within the priority queue
 */
template<typename E, typename K>
class facade {
private:
    E m_element;
    K m_key;
public:
    // =========================================================================================
    // class constructors
    // =========================================================================================

    // The following ctors will be generated by the compiler since this is a simple definition.
    facade() = default;
    facade(const facade&) = default;

    // user defined ctor that will be called by the user
    facade(E element, K key) : m_element(element), m_key(key) {}

    // ==============================================================================
    // class operator implementations
    // ==============================================================================

    // this operator is used to determine if two instances are the same or not.
    facade& operator=(const facade& other) {
        if (this != &other) {
            m_element = other.m_element;
            m_key = other.m_key;
        }
        return *this;
    }

    // return a pointer to this facade is wrapping.
    E& operator()() { return m_element; }

    bool operator!=(const facade other) { return m_key != other.m_key; }
    bool operator>(const facade& other) const { return m_key > other.m_key; }
    bool operator<(const facade& other) const { return m_key < other.m_key; }

    // ==================================================================================
    // user defined class methods.
    // ==================================================================================

    const K& key() const { return m_key; }
    const E& element() const { return m_element; }
};

TEST(PriorityQueueExtendedTestSuite, FacadePriorityQueueExtendedTest) {
    vector<city> data = { { "Boston"}, { "New York"}, { "Toronto" }, { "Los Angelas" } };
    vector<int> distances = { 2, 5, 1, 11 };
    priority_queue_ex<facade<city,int> > pq;

    auto dataItr = data.begin();
    auto distanceItr = distances.begin();

    for( ; dataItr != data.end() ; dataItr++, distanceItr++ ) {
        city element = *dataItr;
        int key = *distanceItr;
        facade<city,int> f(element, key);
        cout << "Created facade for element: " << f() << " and key: " << f.key() << "  using element: " << element << " and key: " << key << endl;
        pq.push(f);
        element = f.element();
        cout << "Added: " << element << endl;
    }

    while ( ! pq.empty() ) {
        auto f = pq.top();
        city& element = f();
        cout << "Retreived: " << element << endl;
        pq.pop();
    }
}

TEST(PriorityQueueExtendedTestSuite, PriorityQueueExtendedTest) {
    vector<string> data = { "foo", "bar", "joe", "tony" };
    vector<int> keys = { 11, 6, 88, 13 };
    vector<node<string> > nodes;
    priority_queue_ex<wrapper<string,int> > pq;
    vector<wrapper<string,int> > wrapped;

    auto keyItr = keys.begin();

    cout << "Creating an priority queue instance." << endl;
    for (auto dataItr = data.begin() ; dataItr != data.end() ; dataItr++, keyItr++) {
        string& name = *dataItr;
        int key  = *keyItr;
        node<string> current(name);
        nodes.push_back(current);

        node<string>& nn = nodes.back();
        cout << "Adding the node with element " << name << " to the priority queue." << endl;
        wrapped.push_back(wrapper<string,int>(nn, key));
        pq.push(wrapped.back());

        cout << "Added the node with element " << name << " to the priority queue." << endl;
        const wrapper<string,int>& top = pq.top();
        const node<string>& n = top.node();
    }
    cout << "Created the priority queue instance." << endl;

    while ( ! pq.empty() ) {
        cout << "Processing a priority queue entry" << endl;
        wrapper<string,int> top = pq.top(); pq.pop();
        cout << "Top: " << top << endl;
    }
}

TEST(ContainerTestSuite, ContainerEndTest) {
    vector<int> v;
    ASSERT_EQ(v.begin(), v.end());
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
